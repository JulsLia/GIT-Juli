<!doctype html>
<html>
    <head>
        <meta charset="utf-8">    
        <title>Комбинации селекторов и специфичность</title>
    </head>
<body>
    <h1> Основы CSS. Комбинации селекторов и специфичность. </h1>
    <h2>Комбинации селекторов</h2>
    <p> Селекторы можно комбинировать друг с другом используя, так называемые комбинаторы, что в итоге позволяет сократить код и нацелить стиль на выбранные элементы, основываясь на их положении относительно друг друга.</p>
    <h3>Комбинаторы:</h3>
<ol>
    <li><h4>Комбинатор запятая (Группирование селекторов (А, B))</h4></li>
    Комбинатор, позволяет сгруппировать селекторы, т.е. если нескольким селекторам нужно задать одно и то же правило, то можно написать длинно:

    <p> h1 {</p>
      <p> font-weight: bold;</p>
    <p> }</p>
    
    <p>h2 {</p>
        <p>font-weight: bold;</p>
        <p>}</p>
    
        <p>h3 {</p>
            <p>font-weight: bold;</p>
            <p>}</p>
            <p>А можно перечислить все селекторы через запятую и написать всего одно CSS-правило:</p>

            <p>h1, h2, h3 {</p>
                <p>font-weight: bold;</p>
                <p>}</p> 
                <p>Селекторы группируются в виде списка, пункты которого разделяются между собой запятыми. В группу могут входить не только селекторы элементов, но также идентификаторы и классы.</p> 
                <p>h2, .selector1, #id { </p>
                    <p>background: #fff; </p>
                    <p>}</p>
                    <h4>Дерево документа</h4>
<p>Большинство комбинаций селекторов основано на их положении в дереве документа и относительно друг друга. Дерево документа — это схематичное изображение всех элементов, встречающихся в нашем коде HTML. Для иллюстрации возьмём произвольный документ:</p>
<p>&lt;!DOCTYPE html&gt;</p>
<p>&lt;html&gt;</p>
 <p>&lt;head&gt;</p>
  <p>&lt;meta charset="utf-8"&gt;</p>
  <p>&lt;title&gt;Сальса&lt;/title&gt;</p>
<p>&lt;/head&gt;</p>
 <p>&lt;body&gt;</p> 
  <p>&lt;header&gt;</p>
   <p>&lt;h1&gt;Сальса&lt;/h1&gt;</p>
   <p>&lt;ul&gt;</p>
    <p>&lt;li&gt;&lt;a href="#"&gt;Uno&lt;/a&gt;&lt;/li&gt;</p>
    <p>&lt;li&gt;&lt;a href="#"&gt;Dos&lt;/a&gt;&lt;/li&gt;</p>
    <p>&lt;li&gt;&lt;a href="#"&gt;Tres&lt;/a&gt;&lt;/li&gt;</p>
<p>&lt;/ul&gt;</p>
  <p>&lt;/header&gt;</p>
  <p>&lt;main&gt;</p>
   <p>&lt;p&gt;Сальса — современный социальный танец. Как многие 
   латиноамериканские танцы, сальса экспрессивна, 
   разнообразна и богата импровизацией.&lt;/p&gt;</p>
  <p>&lt;/main&gt;</p>
  <p>&lt;footer&gt;</p>
   <p>&lt;ul&gt;</p>
    <p>&lt;li&gt;&lt;a href="#"&gt;Cinco&lt;/a&gt;&lt;/li&gt;</p>
    <p>&lt;li&gt;&lt;a href="#"&gt;Seis&lt;/a&gt;&lt;/li&gt;</p>
    <p>&lt;li&gt;&lt;a href="#"&gt;Siete&lt;/a&gt;&lt;/li&gt;</p>
   <p>&lt;/ul&gt;</p> 
  <p>&lt;/footer&gt;</p>
 <p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>Дерево документа для этого HTML показано на рисунке п ссылке <a href="https://webref.ru/assets/images/css-tutorial/element-tree.png" target="_blank">Изображение Дерево документа.</a> Схема напоминает крону дерева из-за своей схожести с ветвями и листьями.</p>

<p>&lt;!doctype&gt; не считается элементом, поэтому его в расчёт не берём. Сама схема начинается с элемента &lt;html&gt;, он называется «корневой элемент». Все элементы связаны друг с другом сверху вниз и между ними есть следующие связи.</p>

<p><strong>Предок</strong></p>
<p>Элемент, внутри которого располагаются другие элементы с произвольным уровнем вложения. Для &lt;p&gt; предками будут &lt;main&gt;, &lt;body&gt; и &lt;html&gt;.</p>
<p><strong>Потомок</strong></p>
<p>Элемент, расположенный внутри одного или нескольких предков. К примеру, &lt;a&gt; является потомком как &lt;li&gt;, так и &lt;ul&gt;, поскольку располагается внутри них.</p>
<p><strong>Родитель</strong></p>
<p>Непосредственный предок элемента, который располагается выше на один уровень в дереве документа. &lt;header&gt; будет родителем для &lt;ul&gt;, но уже не для &lt;li&gt;, для него родителем будет выступать &lt;ul&gt;.</p>
<p><strong>Ребёнок (дочерний элемент)</strong></p>
<p>Непосредственный потомок элемента, который располагается ниже на один уровень в дереве документа. К примеру, дочерним для &lt;main&gt; будет элемент &lt;p&gt;; для &lt;ul&gt; дочерними элементами выступают &lt;li&gt;, но не &lt;a&gt;. У родителя может быть произвольное число дочерних элементов, но у дочернего элемента только единственный родитель.</p>
<p><strong>Братья (сиблинги)</strong></p>
<p>Элементы, расположенные на одной ветке и имеющие общего родителя, называются братскими или сиблинги, если пользоваться термином из генетики. Братскими являются элементы &lt;header&gt;, &lt;main&gt; и &lt;footer&gt;, а также &lt;li&gt;. Элементы &lt;a&gt; братскими не являются из-за того, что у них разные родители.</p>
<p><strong>Смежные</strong></p>
<p>Братские элементы, расположенные рядом друг с другом. Смежными будут элементы &lt;header&gt; и &lt;main&gt;, а также &lt;main&gt; и &lt;footer&gt;, но никак не &lt;header&gt; и &lt;footer&gt;, потому что они располагаются «через одного».</p>
                    <li><h4>Комбинатор пробел (Селекторы потомка (A B) или комбинатор потомков)</h4></li>
                    <p>Эти селекторы также называются вложенными или контекстными. Такие селекторы состоят из базовых селекторов разделённых пробелом. Последовательность селекторов отражает вложенность — каждый следующий селектор должен обязательно находиться на каком-то уровне вложенности в предыдущий селектор.</p>
                    <p>article h3 {</p>
                        <p> color: red;</p>
                      <p>}</p>
                      <p>Селекторов не обязательно должно быть только два, можно комбинировать произвольное количество.</p>
                        <p>.tbl thead td { </p>
                            <p>background: #f0f0f0; </p>
                        <p>}</p>
                        <p>Здесь серый фон добавляется к ячейкам таблицы <td>, когда они располагаются внутри <thead>, а тот в свою очередь внутри элемента с классом tbl.</p>
<li><h4>Дочерний комбинатор (Дочерние селекторы (A > B))</h4></li>
<p>Селекторы потомка выбирают всех заданных потомков указанного элемента, независимо от их уровня вложенности. Чтобы выбрать только дочерние элементы, между селекторами вставляется угловая скобка >.</p>
<p>Последовательность селекторов отражает непосредственную вложенность — селектор справа от оператора должен быть прямым потомком селектора из левой части:

    <p>article > h3 {</p>
      <p>color: red;</p>
    <p>}</p>
    <p>пример 1</p>

</p>section > h2 {</p> 
    <p>color: red;</p> 
<p>}</p>
         <p>пример 2</p>  
         <p>В примере 2 запись означает применить стиль к элементу &lt;h2&gt;, который является дочерним по отношению к &lt;section&gt;. Для следующего фрагмента HTML красным цветом будет оформлен первый заголовок &lt;h2&gt;, поскольку только он непосредственно располагается внутри &lt;section&gt; и выступает его дочерним элементом.</p> 
            <p>Дочерние селекторы обычно применяются для ситуаций, когда одинаковые элементы вкладываются внутрь другого несколько раз, но выделить нужно не все, а только определённые элементы. В примере 3 показано создание меню, когда один &lt;ul&gt; располагается внутри другого. Чтобы стилизовать пункты списка первого уровня, не затрагивая остальные, и требуются дочерние селекторы.</p>  
            <p>&lt;body&gt;</p> 
                <p>&lt;ul class="menu"&gt;</p>
                 <p>&lt;li&gt;Пункт 1&lt/li&gt</p>
                 <p>&lt;li&gt;Пункт 2</p>
                  <p>&lt;ul&gt;</p>
                   <p>&lt;li&gt;Пункт 2.1&lt;/li&gt;</p>
                   <p>&lt;li&gt;Пункт 2.2&lt;/li&gt;</p>
                   <p>&lt;li&gt;Пункт 2.3&lt;/li&gt;</p>
                  <p>&lt;/ul&gt;</p>
                 <p>&lt;/li&gt;</p>
                 <p>&lt;li&gt;Пункт 3&lt;/li&gt;</p>
                <p>&lt;/ul&gt;</p>
               <p>&lt;/body&gt;</p>  
               <p>Пример 3</p>   
               <p>И так это будет выглядеть в браузере </p>
               <p><body> 
                <ul class="menu">
                 <li>Пункт 1</li>
                 <li>Пункт 2
                  <ul>
                   <li>Пункт 2.1</li>
                   <li>Пункт 2.2</li>
                   <li>Пункт 2.3</li>
                  </ul>
                 </li>
                 <li>Пункт 3</li>
                </ul> 
               </body></p>
               <li><h4>Комбинатор следующего соседнего элемента (Смежные селекторы (A + B))</h4></li>
            <p>Селекторы объединяются знаком +.</p>
            <p>Элемент справа от + должен следовать в HTML сразу за элементом слева от +. Проще говоря, правый элемент должен быть соседом левого элемента, чтобы смежный селектор сработал.</p>

<p>Код из примера применится только к такому &lt;input&gt;, который стоит сразу после &lt;label&gt;:</p>
<p>label + input {</p>
  <p>color: red;</p>
<p>}</p>
<p>К этому не применится, т. к. перед &lt;input&gt; идёт &lt;p&gt;:</p>

    <p>&lt;label&gt;&lt;/label&gt;</p>
    <p>&lt;p&gt;…&lt;/p&gt;</p>
    <p>&lt;input&gt;</p>
    
    <p>При такой разметке стиль применится только к первому &lt;input&gt;, но не ко второму:</p>
    
    <p>&lt;label&gt;Лейбл&lt;/label&gt;</p>
    <p>&lt;input&gt;</p>
    <p>&lt;input&gt;</p>
    
    <p>И тут правило не сработает. &lt;label&gt; и &lt;input&gt; — на разных уровнях вложенности:</p>
    
    <p>&lt;label&gt;Лейбл&lt;/label&gt;</p>
    <p>&lt;div&gt;</p>
      <p>&lt;input&gt;</p>
    <p>&lt;/div&gt;</p>
    <li><h4>Комбинатор всех соседних элементов (Братские селекторы (A ~ B))</h4></li>
    <p>Селекторы объединяются с помощью символа ~.</p>
    <p>Выбирает все соседние элементы B, которые идут в коде после элемента A. Слово «соседний» в данном случае обозначает, что будут выбраны все элементы находящиеся после указанного. К примеру, следующая запись изменит цвет всех абзацев после заголовка.</p>

        <p>h2 ~ p { </p>
            <p>color: red; </p>
        <p>}</p>
</ol>
<h2>Специфичность</h2>
<h3>Что такое специфичность селекторов</h3>
<p>Разработчики часто применяют к одному элементу сразу несколько CSS-правил. Если два свойства из разных правил конфликтуют, браузер смотрит на селекторы. Свойство из CSS-правила с более «сильным» селектором побеждает в конфликте.
 💡 Специфичность определяет приоритет CSS-правил у разных селекторов. Специфичность — это одно из базовых понятий в CSS.</p>
<p>Специфичность представляет собой вес, придаваемый конкретному правилу CSS. Вес правила определяется количеством каждого из типов селекторов в данном правиле. Если у нескольких правил специфичность одинакова, то к элементу применяется последнее по порядку правило CSS. Специфичность имеет значение только в том случае, если один элемент соответствует нескольким правилам. Согласно спецификации CSS, правило для непосредственно соответствующего элемента всегда будет иметь больший приоритет, чем правила, унаследованные от предка.</p>
    <h4>Как распределяется специфичность:</h4>
<ul>
<li>Наибольшая специфичность у встроенных стилей (например, style="font-weight:bold"), они всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.</li>
<li>Меньше — у селекторов идентификаторов (например, #example).</li>
<li>Ещё меньше — у классов (например, .example), псевдоклассов (например, :hover) и селекторов атрибутов (например, [type="radio"]) .</li>
<li>Самый низкий приоритет у селекторов типов элементов (например, h1)  и псевдоэлементов (например, ::before).</li>
</ul>
<p>«Перебить» специфичность встроенных стилей можно только одним способом — использовать модификатор !important. Хотя технически модификатор !important не имеет со специфичностью ничего общего, он непосредственно на неё влияет. Поскольку !important усложняет отладку, нарушая естественное каскадирование ваших стилей, он не приветствуется и следует избегать его использования. Если к элементу применимы два взаимоисключающих стиля с модификатором !important, то применён будет стиль с большей специфичностью.</p>
<p>Универсальный селектор (*), комбинаторы (+, >, ~, '``') и отрицающий псевдокласс (:not()) не влияют на специфичность. (Однако селекторы, объявленные внутри :not(), влияют)</p>
<h4>Специфичность основана на форме</h4>
<p>Специфичность опирается на форму селектора. В следующем примере, при определении специфичности селектора, селектор *[id="foo"] считается селектором атрибута, даже при том, что ищет идентификатор.</p>
<p>Эти объявления стилей ...</p>

<p>*#foo {</p>
  <p>color: green;</p>
<p>}</p>
<p>*[id="foo"] {</p>
  <p>color: purple;</p>
<p>}</p>
<p>... применённые к нижеследующей разметке ...</p>

&lt;p id="foo"&gt;Это пример.&lt;/p&gt;
<p>... в результате выглядят так:</p>
<p style="color:green" p id="foo">Это пример.</p>
<p>Потому что оба правила соответствуют одному и тому же элементу, но селектор идентификатора имеет большую специфичность.</p>
<h4>Независимость от расположения</h4>
<p>Взаимное расположение элементов, указанных в селекторе не влияет на специфичность правила. Следующие объявления стилей ...</p>
<p>body h1 {</p>
    <p>color: green;</p>
  <p>}</p>
  <p>html h1 {</p>
    <p>color: purple;</p>
  <p>}</p>
  <p>... в сочетании со следующим HTML ...</p>
  <p>&lt;html&gt;</p>
<p>&lt;body&gt;</p>
  <p>&lt;h1&gt;Вот заголовок!&lt;/h1&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>
<p>&lt;/body&gt;</p>
<p>... отобразится как:</p>
<h1 style="color:purple">Вот заголовок!</h1>
<p>Потому что, хотя оба объявления имеют одинаковое количество типов селекторов, но селектор html h1 объявлен последним.</p>
<h4>Непосредственно соответствующие элементы и унаследованные стили</h4>
<p>Стили непосредственно соответствующих элементов всегда предпочитаются унаследованным стилям, независимо от специфичности унаследованного правила. Этот CSS ...</p>
<p>#parent {</p>
   <p>color: green;</p>
  <p> }</p>
    <p>h1{</p>
    <p>color: purple;</p>
  <p>}</p>
  <p>... с таким HTML ...</p>
  <p>&lt;html&gt;</p>
<p>&lt;body id="parent"&gt;</p>
  <p>&lt;h1&gt;Вот заголовок!&lt;/h1&gt;</p>
<p>&lt;/body&gt;</p>
<p>&lt;/html&gt;</p>

<p>... тоже отобразится как:</p>
<h1 style="color:purple">Вот заголовок!</h1>
<p>Потому что селектор h1 непосредственно соответствует элементу, а стиль, задающий зелёный цвет, всего лишь унаследован от родителя.</p>

<h4>Не исключение - :not()</h4>
<p>Отрицающий псевдокласс :not не учитывается как псевдокласс при расчёте специфичности. Однако селекторы, расположенные внутри :not, при подсчёте количества по типам селекторов рассматриваются как обычные селекторы и учитываются.</p>
<p>Следующий фрагмент CSS ...</p>
<p>div.outer p {</p>
    <p>color: orange;</p>
  <p>}</p>
  <p>div:not(.outer) p {</p>
    <p>color: lime;</p>
  <p>}</p>
  <p>... применённый к такому HTML ...</p>
  <p>&lt;div class="outer"&gt;</p>
    <p>&lt;p&gt;Это div.outer&lt;/p&gt;</p>
    <p>&lt;div class="inner"&gt;</p>
      <p>&lt;p&gt;Это текст в div.inner&lt;/p&gt;</p>
    <p>&lt;/div&gt;</p>
  <p>&lt;/div&gt;</p>
<p>... отобразится на экране так:</p>
<p style="color:orange">Это div.outer</p>
<p style="color:lime">Это текст в div.inner</p>

 </body>
</html>



